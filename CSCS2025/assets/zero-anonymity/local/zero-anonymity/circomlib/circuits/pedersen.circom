/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.0.0;

include "escalarmul.circom";

template Pedersen(n) {
    signal input in[n];
    signal output out[2];

    var nexps = ((n-1) \ 250) + 1;
    var nlastbits = n - (nexps-1)*250;

    component escalarMuls[nexps];

    var PBASE[10][2] = [
        [10457101036533406547632367118273992217979173478358440826365724437999023779287,19824078218392094440610104313265183977899662750282163392862422243483260492317],
        [9524723677535844723712009920813008280306120281019823422168347197553901482452,13221008764645795902678657332942040755708758185876053969419417456492525748262],
        [14291542398303421970260264765913066046481571932341590453341647820432512139837,13744202053624027493847026160280053112047436671392491578937933650870596916048],
        [8651535444802942753508589745546128178596768354933761602652034353732462172078,12787568075624105253522659923795284314068612865106462222618033471708573050619],
        [2075148949735710791033803326695565114349959755591956384164263949761889126223,2469135120245024497995265308425332151766338576614445301897432617183189683781],
        [7281168317310714098699300606749322962375459954817215803336916492842895547093,7064819845008159346186809750130967240417111446461726924680242222918929567126],
        [12125079028816141705816308498156193851533865560550831766042570713442530086984,17274281346925925348006378607857249107087865885886916842442567422334745308034],
        [20401466987415004314846888404615491140015362176367232646096759829376612019557,8213015347402152123031737585995985377287810952364617418311700413841618192560],
        [17106599268156086140784783747320068115594023395718483635221349738936521855137,20196416508359292900461995331089905749230616213186030889941054867414611404057],
        [7354107933004819338895606957398406775897967492286581435272951431887359378618,14012455978760899186703294654556284000268889615030939814562578448675796024785]
    ];
    var i;
    var j;
    var nexpbits;
    for (i=0; i<nexps; i++) {
        nexpbits = (i == nexps-1) ? nlastbits : 250;
        escalarMuls[i] = EscalarMul(nexpbits, PBASE[i]);

        for (j=0; j<nexpbits; j++) {
            escalarMuls[i].in[j] <== in[250*i + j];
        }

        if (i==0) {
            escalarMuls[i].inp[0] <== 0;
            escalarMuls[i].inp[1] <== 1;
        } else {
            escalarMuls[i].inp[0] <== escalarMuls[i-1].out[0];
            escalarMuls[i].inp[1] <== escalarMuls[i-1].out[1];
        }
    }

    escalarMuls[nexps-1].out[0] ==> out[0];
    escalarMuls[nexps-1].out[1] ==> out[1];
}
